"use strict";
// Copyright 2020 Vonage
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vetch = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const querystring_1 = require("querystring");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const types_1 = require("./types");
class Vetch {
    constructor(defaults) {
        this.defaults = defaults || { responseType: types_1.ResponseTypes.json };
        if (!this.defaults.responseType) {
            this.defaults.responseType = types_1.ResponseTypes.json;
        }
    }
    _defaultAdapter(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield (0, node_fetch_1.default)(opts.url, opts);
            const data = yield this.getResponseData(opts, res);
            return this.createResponse(opts, res, data);
        });
    }
    request(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            opts = this.validateOpts(opts);
            try {
                let formattedResponse;
                formattedResponse = yield this._defaultAdapter(opts);
                if (!opts.checkStatus(formattedResponse.status)) {
                    const err = new types_1.VetchError(`Request failed with status code ${formattedResponse.status}`, opts);
                    err.code = String(formattedResponse.status);
                    err.response = formattedResponse;
                    throw err;
                }
                return formattedResponse;
            }
            catch (e) {
                throw e;
            }
        });
    }
    getResponseData(opts, res) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (opts.responseType) {
                case 'json': {
                    let data = yield res.text();
                    try {
                        data = JSON.parse(data);
                    }
                    catch (_a) {
                        // continue
                    }
                    return data;
                }
                default:
                    return res.text();
            }
        });
    }
    validateOpts(options) {
        const opts = (0, lodash_merge_1.default)({}, this.defaults, options);
        opts.headers = opts.headers || {};
        opts.checkStatus = this.checkStatus;
        opts.responseType = opts.responseType;
        if (!opts.url) {
            throw new Error('URL is required.');
        }
        const baseUrl = opts.baseUrl || opts.baseURL;
        if (baseUrl) {
            opts.url = baseUrl + opts.url;
        }
        if (opts.params) {
            let queryParams = (0, querystring_1.stringify)(opts.params);
            if (queryParams.startsWith('?')) {
                queryParams = queryParams.slice(1);
            }
            const prefix = opts.url.includes('?') ? '&' : '?';
            opts.url = `${opts.url}${prefix}${queryParams}`;
        }
        if (opts.data) {
            if (typeof opts.data === 'object') {
                opts.body = JSON.stringify(opts.data);
                opts.headers['Content-Type'] = 'application/json';
            }
            else {
                opts.body = opts.data;
            }
        }
        if (!opts.headers.Accept && opts.responseType === 'json') {
            opts.headers.Accept = 'application/json';
        }
        // Set our user agent
        opts.headers['user-agent'] = `@vonage/server-sdk/3.0.0 node/${process.version.replace('v', '')}`;
        // Allow a custom timeout to be used
        const httpAgent = new http_1.default.Agent({
            timeout: this.defaults.timeout,
        });
        const httpsAgent = new https_1.default.Agent({
            timeout: this.defaults.timeout,
        });
        opts.agent = (parsedUrl) => {
            if (parsedUrl.protocol === 'http:') {
                return httpAgent;
            }
            else {
                return httpsAgent;
            }
        };
        return opts;
    }
    checkStatus(status) {
        return status >= 200 && status < 300;
    }
    createResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            config: opts,
            data: data,
            headers,
            status: res.status,
            statusText: res.statusText,
            request: {
                responseUrl: res.url,
            },
        };
    }
}
exports.Vetch = Vetch;
