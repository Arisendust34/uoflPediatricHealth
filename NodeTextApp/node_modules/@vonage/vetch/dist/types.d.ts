/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import http from 'node:http';
import https from 'node:https';
export declare class VetchError extends Error {
    code?: string;
    config: VetchOptions;
    response: VetchResponse<any>;
    constructor(message: string, options: VetchOptions);
}
export interface Headers {
    [index: string]: any;
}
export interface VetchHttpRequest {
    responseUrl: string;
}
export declare type VetchPromise<T> = Promise<VetchResponse<T>>;
export declare const VetchPromise: PromiseConstructor;
export declare type NumbersResponse<T> = VetchResponse<T>;
export interface VetchResponse<T> {
    config: VetchOptions;
    data: T;
    error?: true;
    status: number;
    statusText: string;
    headers: Headers;
    request: VetchHttpRequest;
}
export declare enum HTTPMethods {
    GET = "GET",
    HEAD = "HEAD",
    POST = "POST",
    DELETE = "DELETE",
    PUT = "PUT",
    CONNECT = "CONNECT",
    OPTIONS = "OPTIONS",
    TRACE = "TRACE",
    PATCH = "PATCH"
}
export declare enum ResponseTypes {
    json = "json"
}
export interface VetchOptions {
    adapter?: <T = any>(options: VetchOptions, defaultAdapter: (options: VetchOptions) => VetchPromise<T>) => VetchPromise<T>;
    url?: string;
    baseUrl?: string;
    baseURL?: string;
    method?: HTTPMethods;
    headers?: Headers;
    data?: any;
    body?: any;
    params?: any;
    responseType?: ResponseTypes;
    checkStatus?: (status: number) => boolean;
    size?: number;
    timeout?: number;
    agent?: boolean | http.Agent | https.Agent | ((parsedUrl: URL) => boolean | https.Agent | http.Agent);
}
