"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const jwt_1 = require("@vonage/jwt");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const types_1 = require("./types");
class Auth {
    constructor(opts) {
        // add additional methods to find auth
        // also needs to handle private key, etc
        this.getQueryParams = (params) => {
            return Object.assign({ api_key: this.apiKey, api_secret: this.apiSecret }, params);
        };
        this.createBasicHeader = () => {
            const buf = Buffer.from(`${this.apiKey}:${this.apiSecret}`);
            return 'Basic ' + buf.toString('base64');
        };
        this.createBearerHeader = () => {
            return 'Bearer ' + (0, jwt_1.tokenGenerate)(this.applicationId, this.privateKey);
        };
        this.createSignatureHash = (params) => {
            const returnParams = Object.assign({ api_key: this.apiKey }, params);
            // Add the current timestamp to the parameters list with the key 'timestamp'.
            // This should be an integer containing the number of seconds since the epoch (UNIX time))
            returnParams.timestamp = Math.floor(Date.now() / 1000).toString();
            // Loop through each of the parameters, sorted by key.
            // For every value in the parameter list, replace all instances of & and = with an underscore _.
            const keys = Object.keys(returnParams);
            const stringifiedParamsforSigning = keys
                .sort()
                .map((keyName) => {
                // Generate a string consisting of &akey=value
                return `&${keyName}=${returnParams[keyName]
                    .toString()
                    .replace(/(&|=)/gi, '_')}`;
            }, [])
                .join('');
            // For hash
            // Add signature secret to the end of the string, directly after the last value.
            // It should now look something like this: '&akey=value&bkey=value${your_signature_secret}'
            // Now run the string through an md5 hash function
            // convert the resulting bytes to a string of hexadecimal digits.
            // This is your MD5 hash signature,
            // Should be added to the HTTP parameters of your request as the 'sig' parameter.
            if (this.signature.algorithm === types_1.AlgorithmTypes.md5hash) {
                returnParams.sig = (0, crypto_1.createHash)('md5')
                    .update(stringifiedParamsforSigning + this.signature.secret)
                    .digest('hex');
            }
            // For HMAC
            // Create an HMAC generator with your desired algorithm and your signature secret as the key.
            // Now run the string through an hmac generator
            // convert the resulting bytes to a string of hexadecimal digits.
            // This is your HMAC signature,
            // Should be added to the HTTP parameters of your request as the sig parameter
            if (this.signature.algorithm === types_1.AlgorithmTypes.md5hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('md5', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.sha1hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('sha1', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.sha256hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('sha256', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.sha512hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('sha512', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            return returnParams;
        };
        this.apiKey = (opts === null || opts === void 0 ? void 0 : opts.apiKey) || '';
        this.apiSecret = (opts === null || opts === void 0 ? void 0 : opts.apiSecret) || '';
        this.signature = (opts === null || opts === void 0 ? void 0 : opts.signature) || null;
        this.applicationId = (opts === null || opts === void 0 ? void 0 : opts.applicationId) || null;
        if (opts === null || opts === void 0 ? void 0 : opts.privateKey) {
            if ((0, fs_1.existsSync)(opts.privateKey)) {
                opts.privateKey = (0, fs_1.readFileSync)(opts.privateKey).toString();
            }
            if (opts.privateKey instanceof Buffer) {
                this.privateKey = opts.privateKey.toString();
            }
            else {
                this.privateKey = opts.privateKey;
            }
        }
    }
}
exports.Auth = Auth;
